# Windows日志收集系统：命名管道 vs 共享内存

## 架构对比

### 命名管道版本
- **通信方式**：基于Windows命名管道（Named Pipes）
- **连接模型**：客户端-服务器模型，每个客户端需要建立独立连接
- **数据传输**：通过管道进行读写操作
- **同步机制**：每条消息需要等待ACK确认

### 共享内存版本
- **通信方式**：基于Windows共享内存（Shared Memory）
- **连接模型**：多进程共享同一内存区域
- **数据传输**：直接内存访问，使用环形缓冲区
- **同步机制**：原子操作 + 事件通知

## 性能特征对比

| 特性 | 命名管道 | 共享内存 |
|------|----------|----------|
| **延迟** | 中等（~0.1-1ms） | 极低（~1-10μs） |
| **吞吐量** | 10K-50K msg/s | 100K-1M msg/s |
| **CPU开销** | 较高（系统调用） | 较低（用户态操作） |
| **内存使用** | 动态分配 | 预分配固定大小 |
| **扩展性** | 受连接数限制 | 受内存大小限制 |
| **隔离性** | 进程间完全隔离 | 共享内存区域 |

## 使用场景建议

### 适合使用命名管道的场景：
1. **中等并发量**（<100个客户端）
2. **需要可靠传输**，每条消息都需要确认
3. **消息大小变化较大**
4. **需要进程间隔离**
5. **简单的请求-响应模式**

### 适合使用共享内存的场景：
1. **超高并发**（>1000个客户端）
2. **极低延迟要求**（微秒级）
3. **高吞吐量要求**（>100K msg/s）
4. **消息大小相对固定**
5. **可以容忍少量消息丢失**

## 实现细节对比

### 命名管道实现特点：
```cpp
// 优点
- 自动处理进程生命周期
- 内置流控制
- 支持双向通信
- Windows安全模型集成

// 缺点
- 每次通信需要系统调用
- 连接建立开销较大
- 受系统资源限制
```

### 共享内存实现特点：
```cpp
// 优点
- 极低的访问延迟
- 无需系统调用的数据传输
- 支持批量操作
- 内存映射后接近本地内存访问速度

// 缺点
- 需要手动管理同步
- 固定大小限制
- 崩溃可能影响其他进程
- 需要清理机制
```

## 性能测试结果示例

### 测试环境：
- CPU: Intel i7-9700K
- RAM: 32GB DDR4
- OS: Windows 10 Pro
- 消息大小: 256 bytes

### 测试结果：

#### 单线程性能
| 指标 | 命名管道 | 共享内存 |
|------|----------|----------|
| 延迟 | 0.5ms | 5μs |
| 吞吐量 | 20K msg/s | 200K msg/s |

#### 100并发客户端
| 指标 | 命名管道 | 共享内存 |
|------|----------|----------|
| 总吞吐量 | 50K msg/s | 800K msg/s |
| CPU使用率 | 60% | 25% |
| 内存使用 | 150MB | 100MB |

## 混合架构建议

对于大型系统，可以考虑混合架构：

1. **本地高频日志**：使用共享内存
2. **远程日志传输**：使用命名管道或网络
3. **关键日志**：使用命名管道确保可靠性
4. **性能日志**：使用共享内存减少开销

## 代码使用示例

### 命名管道版本
```bash
# 启动服务器
LogServer.exe --strategy drop-oldest --queue-size 20000

# 启动客户端
LogClient.exe
```

### 共享内存版本
```bash
# 启动服务器
SharedMemoryLogServer.exe --buffer-size 200 --slot-size 4

# 启动客户端
SharedMemoryLogClient.exe
```

## 注意事项

### 命名管道版本：
1. 确保有足够的系统资源处理并发连接
2. 调整缓冲区大小以优化性能
3. 考虑使用重叠I/O提升性能

### 共享内存版本：
1. 需要管理员权限创建Global命名对象
2. 注意内存大小限制
3. 实现崩溃恢复机制
4. 定期清理僵尸槽位

## 总结

- **命名管道**：适合中等规模、需要可靠性的场景
- **共享内存**：适合高性能、低延迟的场景
- 选择合适的方案取决于具体需求
- 可以根据不同日志类型使用不同机制